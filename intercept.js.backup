(function () {
  // Settings and cache management
  let extensionSettings = {
    requestTimeout: 5000,
    cacheTimeout: 86400000, // 24 hours
    serverUrl: 'http://localhost:3001'
  };
  
  let cacheStats = { hits: 0, requests: 0 };
  let forceRefreshMode = false;
  
  // Load settings from chrome storage
  async function loadExtensionSettings() {
    try {
      if (typeof chrome !== 'undefined' && chrome.storage) {
        const result = await chrome.storage.local.get(['carFinderSettings', 'carFinderStats', 'carFinderForceRefresh']);
        if (result.carFinderSettings) {
          extensionSettings = { ...extensionSettings, ...result.carFinderSettings };
          console.log('[‚öôÔ∏è Settings] Loaded from storage:', extensionSettings);
        }
        if (result.carFinderStats) {
          cacheStats = result.carFinderStats;
        }
        
        // Check force refresh mode
        if (result.carFinderForceRefresh) {
          const now = Date.now();
          // Force refresh mode expires after 5 minutes
          if (now - result.carFinderForceRefresh.timestamp < 300000) {
            forceRefreshMode = true;
            console.log('[üîÑ Force Refresh] Mode enabled - bypassing cache');
          } else {
            // Clean up expired force refresh flag
            chrome.storage.local.remove(['carFinderForceRefresh']);
          }
        }
      }
    } catch (error) {
      console.warn('[‚öôÔ∏è Settings] Could not load from storage, using defaults:', error.message);
    }
  }

  // Listen for settings updates from popup
  if (typeof chrome !== 'undefined' && chrome.runtime) {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      if (message.type === 'SETTINGS_UPDATED') {
        extensionSettings = { ...extensionSettings, ...message.settings };
        console.log('[‚öôÔ∏è Settings] Updated from popup:', extensionSettings);
        sendResponse({ success: true });
      } else if (message.type === 'CLEAR_CACHE') {
        analysisCache.clear();
        cacheStats = { hits: 0, requests: 0 };
        console.log('[üóëÔ∏è Cache] Cleared from popup command');
        sendResponse({ success: true });
      } else if (message.type === 'FORCE_REFRESH') {
        forceRefreshMode = true;
        console.log('[üîÑ Force Refresh] Enabled from popup - next analyses will bypass cache');
        sendResponse({ success: true });
        
        // Auto-disable force refresh after 5 minutes
        setTimeout(() => {
          forceRefreshMode = false;
          console.log('[üîÑ Force Refresh] Auto-disabled after 5 minutes');
        }, 300000);
      }
    });
  }

  // Cache system for car analysis
  class CarAnalysisCache {
    constructor() {
      this.cache = new Map();
      this.pendingRequests = new Map(); // ‚úÖ FIX #1: Track requests in progress
      this.loadFromStorage();
    }

    async loadFromStorage() {
      try {
        if (typeof chrome !== 'undefined' && chrome.storage) {
          const result = await chrome.storage.local.get(['carFinderCache']);
          if (result.carFinderCache) {
            this.cache = new Map(Object.entries(result.carFinderCache));
            console.log(`[üíæ Cache] Loaded ${this.cache.size} entries from storage`);
          }
        }
      } catch (error) {
        console.warn('[üíæ Cache] Could not load from storage:', error.message);
      }
    }

    async saveToStorage() {
      try {
        if (typeof chrome !== 'undefined' && chrome.storage) {
          const cacheObj = Object.fromEntries(this.cache);
          const cacheString = JSON.stringify({ carFinderCache: cacheObj });
          const cacheSize = new Blob([cacheString]).size;

          // ‚úÖ FIX #3: Check quota before saving (5MB limit, Chrome has 10MB)
          const MAX_CACHE_SIZE = 5 * 1024 * 1024; // 5MB

          if (cacheSize > MAX_CACHE_SIZE) {
            console.warn(`[‚ö†Ô∏è Cache] Size excessive (${(cacheSize / 1024 / 1024).toFixed(2)}MB), nettoyage...`);
            await this.cleanOldestEntries(MAX_CACHE_SIZE);
            return; // Retry after cleanup
          }

          await chrome.storage.local.set({ carFinderCache: cacheObj });
          console.log(`[üíæ Cache] Saved ${(cacheSize / 1024).toFixed(2)}KB`);
        }
      } catch (error) {
        // ‚úÖ FIX #3: Handle quota exceeded errors
        if (error.message && error.message.includes('QUOTA')) {
          console.error('[üö® Cache] Quota exceeded, emergency cleanup');
          await this.clear();
          this.showError('Cache plein, nettoyage automatique effectu√©');
        } else {
          console.warn('[üíæ Cache] Could not save to storage:', error.message);
        }
      }
    }

    // ‚úÖ FIX #3: New method to clean oldest entries when quota exceeded
    async cleanOldestEntries(targetSize) {
      const entries = Array.from(this.cache.entries())
        .sort((a, b) => a[1].timestamp - b[1].timestamp); // Sort by timestamp (oldest first)

      let removedCount = 0;
      while (entries.length > 0) {
        const [key] = entries.shift();
        this.cache.delete(key);
        removedCount++;

        const currentSize = new Blob([JSON.stringify(Object.fromEntries(this.cache))]).size;
        if (currentSize < targetSize * 0.8) break; // Keep 20% margin
      }

      await chrome.storage.local.set({ carFinderCache: Object.fromEntries(this.cache) });
      console.log(`[üßπ Cache] Cleaned ${removedCount} oldest entries, ${this.cache.size} remaining`);
    }

    showError(message) {
      // Display error notification to user
      if (typeof chrome !== 'undefined' && chrome.notifications) {
        chrome.notifications.create({
          type: 'basic',
          iconUrl: 'icon128.png',
          title: 'CarPriceFinder',
          message: message
        });
      }
    }

    generateKey(carData) {
      // Create unique key based on car characteristics
      const keyData = {
        brand: carData.manufacturerName,
        model: carData.mainType,
        year: new Date(carData.firstRegistrationDate).getFullYear(),
        km: carData.km,
        fuel: carData.fuelType,
        description: (carData.description || '').substring(0, 100), // First 100 chars
        equipment: (carData.equipment || []).sort().join(',').substring(0, 100)
      };
      
      return btoa(JSON.stringify(keyData)).replace(/[/+=]/g, ''); // Base64 encode and clean
    }

    get(carData) {
      const key = this.generateKey(carData);
      const entry = this.cache.get(key);
      
      if (!entry) {
        return null;
      }

      // Check if cache entry is still valid
      const now = Date.now();
      if (now - entry.timestamp > extensionSettings.cacheTimeout) {
        this.cache.delete(key);
        this.saveToStorage();
        console.log(`[üíæ Cache] Expired entry removed for key: ${key.substring(0, 10)}...`);
        return null;
      }

      cacheStats.hits++;
      this.updateStats();
      console.log(`[üíæ Cache] HIT for ${entry.data.brand} ${entry.data.model} (age: ${Math.round((now - entry.timestamp) / 1000 / 60)}min)`);
      return entry.data;
    }

    set(carData, analysisResult) {
      const key = this.generateKey(carData);
      const entry = {
        timestamp: Date.now(),
        data: {
          brand: carData.manufacturerName,
          model: carData.mainType,
          stockNumber: carData.stockNumber,
          analysisResult: analysisResult
        }
      };

      this.cache.set(key, entry);
      this.saveToStorage();
      
      console.log(`[üíæ Cache] STORED analysis for ${carData.manufacturerName} ${carData.mainType} (${carData.stockNumber})`);
      
      // Cleanup old entries if cache gets too large
      if (this.cache.size > 200) {
        this.cleanup();
      }
    }

    cleanup() {
      const now = Date.now();
      let removed = 0;
      
      for (const [key, entry] of this.cache.entries()) {
        if (now - entry.timestamp > extensionSettings.cacheTimeout) {
          this.cache.delete(key);
          removed++;
        }
      }
      
      // If still too large, remove oldest entries
      if (this.cache.size > 150) {
        const entries = Array.from(this.cache.entries())
          .sort((a, b) => a[1].timestamp - b[1].timestamp);
        
        const toRemove = this.cache.size - 150;
        for (let i = 0; i < toRemove; i++) {
          this.cache.delete(entries[i][0]);
          removed++;
        }
      }
      
      if (removed > 0) {
        this.saveToStorage();
        console.log(`[üíæ Cache] Cleaned up ${removed} entries, ${this.cache.size} remaining`);
      }
    }

    updateStats() {
      if (typeof chrome !== 'undefined' && chrome.storage) {
        chrome.storage.local.set({ carFinderStats: cacheStats });
      }
    }

    clear() {
      this.cache.clear();
      this.saveToStorage();
      console.log('[üíæ Cache] Cleared all entries');
    }

    // ‚úÖ FIX #1: Prevent race conditions with pending request tracking
    async fetchAnalysis(carData, fetchUrl, forceRefresh = false) {
      const key = this.generateKey(carData);

      // Check if request already in progress
      if (this.pendingRequests.has(key)) {
        console.log('[üîÑ Cache] Request already in progress, waiting...');
        return await this.pendingRequests.get(key);
      }

      // Check cache first (unless force refresh)
      if (!forceRefresh) {
        const cachedResult = this.get(carData);
        if (cachedResult) {
          return { ...cachedResult, fromCache: true };
        }
      }

      // Create new request promise
      const requestPromise = this._performFetch(carData, fetchUrl, key, forceRefresh);
      this.pendingRequests.set(key, requestPromise);

      try {
        const result = await requestPromise;
        return result;
      } finally {
        // ‚úÖ Cleanup pending request after completion
        this.pendingRequests.delete(key);
      }
    }

    async _performFetch(carData, fetchUrl, key, forceRefresh) {
      try {
        const response = await fetch(fetchUrl);

        // ‚úÖ FIX #2: Handle 429 rate limit with exponential backoff
        if (response.status === 429) {
          const retryAfter = response.headers.get('Retry-After') || 2;
          console.warn(`[‚è≥ Rate Limit] Waiting ${retryAfter}s before retry...`);

          await this._sleep(retryAfter * 1000);
          return await this._performFetch(carData, fetchUrl, key, forceRefresh); // Retry once
        }

        if (!response.ok) {
          throw new Error(`Server error: ${response.status}`);
        }

        const data = await response.json();

        // Cache the result (unless force refresh)
        if (!forceRefresh) {
          this.set(carData, data);
        }

        return { ...data, fromCache: false };

      } catch (error) {
        console.error('[‚ùå Fetch] Error:', error.message);
        throw error;
      }
    }

    _sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  }

  // Initialize cache and settings
  const analysisCache = new CarAnalysisCache();
  loadExtensionSettings();

  // Interception XHR
  const originalXHR = window.XMLHttpRequest;

  function CustomXHR() {
    const xhr = new originalXHR();

    const open = xhr.open;
    xhr.open = function (method, url, ...rest) {
      this._url = url;
      return open.call(this, method, url, ...rest);
    };

    const send = xhr.send;
    xhr.send = function (...args) {
      this.addEventListener("load", function () {
        if (this._url && this._url.includes("/v1/car-search/cars/search")) {
          try {
            const json = JSON.parse(this.responseText);
            console.log("[‚úÖ Intercepted via XHR]", json);
            injectPluginPrices(json.hits);
          } catch (e) {
            console.warn("[‚ùå XHR parse error]", e);
          }
        }
      });

      return send.apply(this, args);
    };

    return xhr;
  }

  window.XMLHttpRequest = CustomXHR;

  console.log("[üöÄ Auto1 interceptor with AI & Cache injected]");

  // Utility functions
  function mapBodyType(body) {
    const map = {
      "van": "utilitaire",
      "sedan": "berline", 
      "hatchback": "berline",
      "suv": "4x4_suv_crossovers",
      "convertible": "cabriolet",
    };
    return map[body.toLowerCase()] || "";
  }

  function mapFuelType(fuelType) {
    switch (fuelType.toLowerCase()) {
      case "petrol": return "1";
      case "diesel": return "2";
      case "electric": return "3";
      case "hybrid": return "4";
      default: return "";
    }
  }

  function mapGearbox(gearType) {
    switch (gearType.toLowerCase()) {
      case "manual": return "1";
      case "automatic": return "2";
      case "duplex": return "2";
      default: return "";
    }
  }

  // Enhanced injection with caching and dynamic timeout
  function injectPluginPrices(hits) {
    console.log(`[üîç injectPluginPrices] ${hits.length} v√©hicules √† traiter (timeout: ${extensionSettings.requestTimeout}ms)`);

    hits.forEach((car, i) => {
      setTimeout(() => {
        const stockId = car.stockNumber;
        const price = car.searchPrice || car.minimumBid || car.mpPrice;

        if (!price) {
          console.log(`[‚ö†Ô∏è VEHICULE ${i}] Pas de prix trouv√© pour ${stockId}`);
          return;
        }

        const euros = (price / 100).toFixed(0) + " ‚Ç¨";
        const card = document.querySelector(`.big-car-card[data-qa-id="${stockId}"]`);

        if (!card) {
          console.log(`[‚ùå VEHICULE ${i}] Carte non trouv√©e pour stockNumber=${stockId}`);
          return;
        }

        if (card.querySelector(".plugin-price")) {
          console.log(`[üîÅ VEHICULE ${i}] Bloc d√©j√† inject√© pour ${stockId}`);
          return;
        }

        // Prepare car data for analysis
        const carDataForAI = {
          manufacturerName: car.manufacturerName,
          mainType: car.mainType,
          description: car.description || car.title || '',
          equipment: car.equipment || car.features || [],
          trim: car.trim || car.variant || '',
          bodyType: car.bodyType,
          fuelType: car.fuelType,
          gearType: car.gearType,
          doors: car.doors,
          seats: car.seats,
          power: car.power || car.horsepower,
          engine: car.engine || car.engineSize,
          exteriorColor: car.exteriorColor,
          interiorColor: car.interiorColor,
          firstRegistrationDate: car.firstRegistrationDate,
          km: car.km,
          price: price,
          stockNumber: stockId
        };

        // Show loading with timeout info and cache status
        const loadingDiv = createLoadingIndicator(extensionSettings.requestTimeout, forceRefreshMode);
        const insertLocation = card.querySelector(".big-car-card__title");
        if (insertLocation && insertLocation.parentNode) {
          insertLocation.parentNode.insertBefore(loadingDiv, insertLocation.nextSibling);
        }

        // Prepare API request
        const searchModel = `${car.manufacturerName} ${car.mainType}`.trim();
        const year = new Date(car.firstRegistrationDate).getFullYear();
        const km = car.km;
        const brand = car.manufacturerName.toUpperCase();
        const fuel = (car.fuelType || "").toLowerCase();
        const gearbox = (car.gearType || "").toLowerCase();
        const carModel = (car.mainType || "").trim();
        const doors = car.doors || "";
        const vehicleType = mapBodyType(car.bodyType || "");

        let estUrl = `${extensionSettings.serverUrl}/api/estimation?model=${encodeURIComponent(searchModel)}&year=${year}&km=${km}&brand=${brand}&fuel=${fuel}&gearbox=${gearbox}&carModel=${encodeURIComponent(carModel)}&doors=${encodeURIComponent(doors)}&carData=${encodeURIComponent(JSON.stringify(carDataForAI))}`;
        if (vehicleType) estUrl += `&vehicle_type=${encodeURIComponent(vehicleType)}`;

        // ‚úÖ FIX #1 & #2: Use new fetchAnalysis method with race condition protection and 429 handling
        cacheStats.requests++;
        analysisCache.fetchAnalysis(carDataForAI, estUrl, forceRefreshMode)
          .then(data => {
            // Remove loading indicator
            const loadingElement = card.querySelector(".plugin-loading");
            if (loadingElement) {
              loadingElement.remove();
            }

            // Render result
            renderCarAnalysis(card, carDataForAI, data, euros, data.fromCache || false);

            const cacheStatus = data.fromCache ? '(from cache)' : '(fresh)';
            console.log(`[‚úÖ VEHICULE ${i}] Analysis complete for ${stockId} ${cacheStatus} (${data.aiAnalysis?.detectedOptions?.length || 0} options detected)`);
          })
          .catch(err => {
            // Remove loading indicator
            const loadingElement = card.querySelector(".plugin-loading");
            if (loadingElement) {
              loadingElement.remove();
            }

            console.warn(`[‚ö†Ô∏è VEHICULE ${i}] Analysis failed for ${stockId}:`, err.message);
            renderErrorMessage(card, err.message);
          });
      }, i * extensionSettings.requestTimeout);
    });
  }

  function createLoadingIndicator(timeout, forceRefresh = false) {
    const loadingDiv = document.createElement("div");
    loadingDiv.className = "plugin-loading";
    loadingDiv.style = "font-weight:bold;font-size:14px;margin:10px 0;color:#17a2b8;border: 1px solid #17a2b8; padding: 8px; border-radius: 5px; background: #e7f3ff;";
    
    const timeoutSec = Math.round(timeout / 1000);
    const refreshStatus = forceRefresh ? ' ‚Ä¢ üîÑ FORCE REFRESH' : '';
    const cacheCount = analysisCache.cache.size;
    
    loadingDiv.innerHTML = `
      <div style="display: flex; align-items: center; gap: 8px;">
        <div style="width: 16px; height: 16px; border: 2px solid #17a2b8; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        <div>
          ü§ñ Analyse IA en cours...
          <div style="font-size:11px;color:#6c757d;">Timeout: ${timeoutSec}s ‚Ä¢ Cache: ${cacheCount} entr√©es${refreshStatus}</div>
        </div>
      </div>
      <style>
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      </style>
    `;
    
    return loadingDiv;
  }

  // ‚úÖ FIX #4: Sanitize HTML to prevent XSS injection
  function sanitizeText(str) {
    if (!str) return '';
    const div = document.createElement('div');
    div.textContent = String(str);
    return div.innerHTML;
  }

  function renderCarAnalysis(card, carData, analysisData, euros, fromCache) {
    const pluginPriceDiv = document.createElement("div");
    pluginPriceDiv.className = "plugin-price";
    pluginPriceDiv.style = "font-weight:bold;font-size:16px;margin:10px 0;color:#007bff;border: 1px solid #007bff; padding: 10px; border-radius: 5px; background: #f8f9fa;";

    // Cache indicator
    const cacheIndicator = fromCache ? '<span style="background:#6c757d;color:white;padding:1px 4px;border-radius:2px;font-size:9px;margin-left:5px;">CACHE</span>' : '';

    // AI Analysis Display - ‚úÖ FIX #4: Safe DOM construction instead of innerHTML
    let aiAnalysisContainer = null;
    if (analysisData.aiAnalysis && analysisData.aiAnalysis.detectedOptions.length > 0) {
      aiAnalysisContainer = document.createElement('div');
      aiAnalysisContainer.style = "font-size:13px;color:#28a745;margin:5px 0;border-bottom:1px solid #dee2e6;padding-bottom:5px;";

      const header = document.createElement('strong');
      header.textContent = 'ü§ñ OPTIONS D√âTECT√âES:';
      aiAnalysisContainer.appendChild(header);

      if (fromCache) {
        const cacheSpan = document.createElement('span');
        cacheSpan.style = "background:#6c757d;color:white;padding:1px 4px;border-radius:2px;font-size:9px;margin-left:5px;";
        cacheSpan.textContent = 'CACHE';
        aiAnalysisContainer.appendChild(cacheSpan);
      }

      aiAnalysisContainer.appendChild(document.createElement('br'));

      // ‚úÖ Safe option badges with sanitized text
      analysisData.aiAnalysis.detectedOptions.forEach(opt => {
        const optSpan = document.createElement('span');
        optSpan.style = "background:#28a745;color:white;padding:2px 6px;border-radius:3px;font-size:11px;margin:0 2px;";
        optSpan.textContent = sanitizeText(opt.name); // ‚úÖ Sanitized
        aiAnalysisContainer.appendChild(optSpan);
      });

      aiAnalysisContainer.appendChild(document.createElement('br'));

      const impact = (analysisData.aiAnalysis.valueImpact * 100).toFixed(1);
      const confidence = (analysisData.aiAnalysis.confidence * 100).toFixed(0);

      const statsSpan = document.createElement('span');
      statsSpan.style = "font-size:11px;color:#6c757d;";
      statsSpan.textContent = `Impact valeur: +${impact}% (confiance: ${confidence}%)`;
      aiAnalysisContainer.appendChild(statsSpan);

    } else if (fromCache) {
      aiAnalysisContainer = document.createElement('div');
      aiAnalysisContainer.style = "font-size:11px;color:#6c757d;margin-bottom:5px;";
      aiAnalysisContainer.textContent = 'ü§ñ Analyse IA';

      const cacheSpan = document.createElement('span');
      cacheSpan.style = "background:#6c757d;color:white;padding:1px 4px;border-radius:2px;font-size:9px;margin-left:5px;";
      cacheSpan.textContent = 'CACHE';
      aiAnalysisContainer.appendChild(cacheSpan);
    }

    const baseEstimate = analysisData.estimatedPrice || "N/A";
    const adjustedEstimate = analysisData.adjustedPrice || baseEstimate;
    const hasAdjustment = analysisData.adjustedPrice && analysisData.adjustedPrice !== analysisData.estimatedPrice;

    const estimateDiv = document.createElement("div");
    estimateDiv.style = "font-size:14px;margin-top:5px;";

    // ‚úÖ FIX #4: Safe DOM construction for prices
    if (aiAnalysisContainer) {
      estimateDiv.appendChild(aiAnalysisContainer);
    }

    if (hasAdjustment) {
      const baseDiv = document.createElement('div');
      baseDiv.style = "color:#dc3545;";
      baseDiv.textContent = `üìà PRIX BASE LBC: ${sanitizeText(baseEstimate)} ‚Ç¨`;
      estimateDiv.appendChild(baseDiv);

      const adjustedDiv = document.createElement('div');
      adjustedDiv.style = "color:#28a745;font-weight:bold;";
      adjustedDiv.textContent = `üöÄ PRIX AJUST√â IA: ${sanitizeText(adjustedEstimate)} ‚Ç¨`;
      estimateDiv.appendChild(adjustedDiv);
    } else {
      const priceDiv = document.createElement('div');
      priceDiv.style = "color:#28a745;";
      priceDiv.textContent = `üìà ESTIMATION LBC: ${sanitizeText(baseEstimate)} ‚Ç¨`;
      estimateDiv.appendChild(priceDiv);
    }

    const realPriceDiv = document.createElement("div");
    realPriceDiv.style = "font-size:13px;color:#6c757d;margin-top:2px;";
    
    // Price filter information (combine with Auto1 price to avoid duplication)
    let priceFilterDiv = '';
    if (analysisData.priceFilter && analysisData.priceFilter.minPriceUsed) {
      const minUsed = analysisData.priceFilter.minPriceUsed;
      const ratio = analysisData.priceFilter.filterRatio;
      realPriceDiv.innerHTML = `üõ†Ô∏è PRIX AUTO1: ${(carData.price / 100).toFixed(0)} ‚Ç¨ ‚Ä¢ üîç Filtre LBC: min ${minUsed}‚Ç¨ (${ratio}%)`;
    } else {
      realPriceDiv.innerText = `üõ†Ô∏è PRIX AUTO1: ${(carData.price / 100).toFixed(0)} ‚Ç¨`;
    }

    // Calculate potential profit
    const auto1Price = carData.price / 100;
    const marketPrice = adjustedEstimate !== "N/A" ? parseInt(adjustedEstimate) : null;
    let profitDiv = '';
    
    if (marketPrice && marketPrice > auto1Price) {
      const profit = marketPrice - auto1Price;
      const profitPercent = ((profit / auto1Price) * 100).toFixed(1);
      profitDiv = `<div style="font-size:12px;color:#17a2b8;margin-top:3px;font-weight:bold;">üí∞ MARGE POTENTIELLE: +${profit}‚Ç¨ (+${profitPercent}%)</div>`;
    }

    // Enhanced LBC button
    const lbcButton = createLbcButton(carData, analysisData);

    // Assemble the price display  
    pluginPriceDiv.innerHTML = `<strong>ü§ñ Analyse CarPriceFinder</strong>`;
    pluginPriceDiv.appendChild(estimateDiv);
    pluginPriceDiv.appendChild(realPriceDiv);
    if (profitDiv) {
      const profitElement = document.createElement("div");
      profitElement.innerHTML = profitDiv;
      pluginPriceDiv.appendChild(profitElement);
    }
    pluginPriceDiv.appendChild(lbcButton);

    // Insert into page
    const finalInsertLocation = card.querySelector(".big-car-card__title");
    if (finalInsertLocation && finalInsertLocation.parentNode) {
      finalInsertLocation.parentNode.insertBefore(pluginPriceDiv, finalInsertLocation.nextSibling);
    }
  }

  // Function to convert Auto1 model names to French LeBonCoin format
  function mapModelToFrench(brand, model) {
    const brandMappings = {
      'BMW': {
        '1er': 'S√©rie 1',
        '2er': 'S√©rie 2', 
        '3er': 'S√©rie 3',
        '4er': 'S√©rie 4',
        '5er': 'S√©rie 5',
        '6er': 'S√©rie 6',
        '7er': 'S√©rie 7',
        '8er': 'S√©rie 8',
        'X1': 'X1',
        'X2': 'X2',
        'X3': 'X3',
        'X4': 'X4',
        'X5': 'X5',
        'X6': 'X6',
        'X7': 'X7',
        'Z4': 'Z4',
        'i3': 'i3',
        'i4': 'i4',
        'i8': 'i8'
      },
      'MERCEDES-BENZ': {
        'A-Klasse': 'Classe A',
        'B-Klasse': 'Classe B', 
        'C-Klasse': 'Classe C',
        'E-Klasse': 'Classe E',
        'S-Klasse': 'Classe S',
        'CLA-Klasse': 'CLA',
        'CLS-Klasse': 'CLS',
        'GLA-Klasse': 'GLA',
        'GLB-Klasse': 'GLB',
        'GLC-Klasse': 'GLC',
        'GLE-Klasse': 'GLE',
        'GLS-Klasse': 'GLS'
      },
      'AUDI': {
        'A1': 'A1',
        'A3': 'A3',
        'A4': 'A4',
        'A5': 'A5',
        'A6': 'A6',
        'A7': 'A7',
        'A8': 'A8',
        'Q2': 'Q2',
        'Q3': 'Q3',
        'Q5': 'Q5',
        'Q7': 'Q7',
        'Q8': 'Q8',
        'TT': 'TT'
      }
    };

    const brandUpper = brand.toUpperCase();
    if (brandMappings[brandUpper] && brandMappings[brandUpper][model]) {
      return brandMappings[brandUpper][model];
    }
    
    return model; // Return original if no mapping found
  }

  function createLbcButton(carData, analysisData) {
    const originalModel = carData.mainType;
    const frenchModel = mapModelToFrench(carData.manufacturerName, originalModel);
    const searchModel = `${carData.manufacturerName} ${frenchModel}`.trim();
    const year = new Date(carData.firstRegistrationDate).getFullYear();
    const km = carData.km;
    const brand = carData.manufacturerName.toUpperCase();
    const fuel = carData.fuelType || '';
    const gearbox = carData.gearType || '';
    const doors = carData.doors || '';

    // Build enhanced search text
    let text = searchModel;
    if (analysisData.aiAnalysis && analysisData.aiAnalysis.detectedOptions.length > 0) {
      const premiumOptions = analysisData.aiAnalysis.detectedOptions.map(opt => opt.name).join(' ');
      text = `${searchModel} ${premiumOptions}`.trim();
    }

    // Add price filter (50% of Auto1 price) to the URL
    const modelParam = encodeURIComponent(`${brand}_${frenchModel}`);
    let lbcUrl = `https://www.leboncoin.fr/recherche?category=2&text=${encodeURIComponent(text)}&regdate=${year-2}-${year+2}&mileage=${Math.max(1, km - 30000)}-${km + 30000}&gearbox=${mapGearbox(gearbox)}&fuel=${mapFuelType(fuel)}&u_car_brand=${brand}&u_car_model=${modelParam}&doors=${doors}&sort=price&order=asc`;
    
    // Add minimum price filter if available
    if (analysisData.priceFilter && analysisData.priceFilter.minPriceUsed) {
      lbcUrl += `&price=${analysisData.priceFilter.minPriceUsed}-max`;
    }

    const lbcButton = document.createElement("button");
    lbcButton.innerText = analysisData.aiAnalysis && analysisData.aiAnalysis.detectedOptions.length > 0 ? 
      "ü§ñ Voir sur LBC (Recherche IA)" : "Voir sur Leboncoin";
    lbcButton.style = "margin-top:8px; padding:8px 12px; background:#007bff; color:white; border:none; cursor:pointer; border-radius:4px; font-size:12px;";
    lbcButton.onclick = () => {
      console.log(`[üñ±Ô∏è Opening LBC] Enhanced search: "${text}"`);
      window.open(lbcUrl, '_blank');
    };

    return lbcButton;
  }

  function renderErrorMessage(card, errorMessage) {
    const errorDiv = document.createElement("div");
    errorDiv.style = "font-size:12px;color:#dc3545;margin:10px 0;padding:8px;border:1px solid #dc3545;border-radius:3px;background:#f8d7da;";

    // ‚úÖ FIX #4: Safe DOM construction for error messages
    const errorTitle = document.createElement('strong');
    errorTitle.textContent = '‚ùå Erreur analyse IA';
    errorDiv.appendChild(errorTitle);
    errorDiv.appendChild(document.createElement('br'));

    const errorText = document.createElement('span');
    errorText.style = "font-size:11px;";
    errorText.textContent = sanitizeText(errorMessage); // ‚úÖ Sanitized
    errorDiv.appendChild(errorText);
    errorDiv.appendChild(document.createElement('br'));

    const closeButton = document.createElement('button');
    closeButton.textContent = 'Fermer';
    closeButton.style = "margin-top:5px;padding:2px 6px;background:#dc3545;color:white;border:none;border-radius:2px;font-size:10px;cursor:pointer;";
    closeButton.addEventListener('click', () => errorDiv.remove()); // ‚úÖ Safe event listener instead of onclick
    errorDiv.appendChild(closeButton);

    const errorInsertLocation = card.querySelector(".big-car-card__title");
    if (errorInsertLocation && errorInsertLocation.parentNode) {
      errorInsertLocation.parentNode.insertBefore(errorDiv, errorInsertLocation.nextSibling);
    }
  }

})();
